/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination;

import it.geosolutions.geobatch.destination.vulnerability.DistancesPair;
import it.geosolutions.geobatch.destination.vulnerability.VulnerabilityComputation;
import it.geosolutions.geobatch.destination.vulnerability.VulnerabilityUtils;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;
import it.geosolutions.process.gs.MultipleBuffer;

import java.awt.RenderingHints;
import java.awt.image.BufferedImage;
import java.awt.image.RenderedImage;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.imageio.ImageIO;
import javax.imageio.stream.ImageInputStream;
import javax.media.jai.JAI;
import javax.media.jai.ParameterBlockJAI;
import javax.media.jai.PlanarImage;
import javax.media.jai.ROI;
import javax.media.jai.RenderedOp;
import javax.media.jai.operator.MosaicDescriptor;

import junit.framework.TestCase;

import org.geotools.data.DataUtilities;
import org.geotools.data.simple.SimpleFeatureCollection;
import org.geotools.data.simple.SimpleFeatureIterator;
import org.geotools.feature.DefaultFeatureCollection;
import org.geotools.feature.SchemaException;
import org.geotools.feature.simple.SimpleFeatureBuilder;
import org.geotools.feature.simple.SimpleFeatureTypeBuilder;
import org.geotools.gce.geotiff.GeoTiffReader;
import org.geotools.geometry.jts.JTS;
import org.geotools.process.feature.gs.AggregateProcess.Results;
import org.jaitools.imageutils.ROIGeometry;
import org.jaitools.media.jai.zonalstats.Result;
import org.jaitools.media.jai.zonalstats.ZonalStats;
import org.jaitools.media.jai.zonalstats.ZonalStatsDescriptor;
import org.jaitools.numeric.Statistic;
import org.junit.Test;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.geometry.MismatchedDimensionException;
import org.opengis.referencing.datum.PixelInCell;
import org.opengis.referencing.operation.MathTransform;
import org.opengis.referencing.operation.TransformException;

import com.sun.media.jai.operator.ImageReadDescriptor;
import com.vividsolutions.jts.geom.Coordinate;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;
import com.vividsolutions.jts.geom.LinearRing;
import com.vividsolutions.jts.geom.Polygon;
import com.vividsolutions.jts.io.ParseException;
import com.vividsolutions.jts.io.WKTReader;

/**
 * @author DamianoG
 *
 */
public class VulnerabilityTest {

    private static final String imageURL = "C:\\Users\\geosolutions\\Documents\\destination\\targets_raster\\RP_BNU-APROT_20121218.tif";
    
    @Test
    public void testVulnerabilityProcess(){
        computeVulnerability();
    }
    
    public static void main(String [] args){
        //computeVulnerability();
        VulnerabilityTest vtest = new VulnerabilityTest();
        
        VulnThread vt1 = vtest.new VulnThread(null, null);
        Thread t1 = new Thread(vt1);
        t1.start();
        
//        VulnThread vt1 = vtest.new VulnThread(1l, 50000l);
//        Thread t1 = new Thread(vt1);
//        t1.start();
        
//        VulnThread vt2 = vtest.new VulnThread(50001l, 100000l);
//        Thread t2 = new Thread(vt2);
//        t2.start();
//        
//        VulnThread vt3 = vtest.new VulnThread(100001l, 150000l);
//        Thread t3 = new Thread(vt3);
//        t3.start();
//        
//        VulnThread vt4 = vtest.new VulnThread(150000l, 207363l);
//        Thread t4 = new Thread(vt4);
//        t4.start();
    }
    
    public static void computeVulnerability(){
        computeVulnerability(null, null);
    }
    
    public static void computeVulnerability(Long start, Long end){
        Map<String, Serializable> datastoreParams = new HashMap<String, Serializable>();
        datastoreParams.put("port", 5432);
        datastoreParams.put("schema", "siig_p");
        datastoreParams.put("passwd", "siig_p");
        datastoreParams.put("dbtype", "postgis");
        datastoreParams.put("host", "192.168.88.132");
        datastoreParams.put("Expose primary keys", "true");
        datastoreParams.put("user", "siig_p");
        datastoreParams.put("database", "destination_staging");
        VulnerabilityComputation vulnerabilityComputation = new VulnerabilityComputation("siig_geo_ln_arco_1", new ProgressListenerForwarder(null));
        try {
            vulnerabilityComputation.setStartOriginId(start);
            vulnerabilityComputation.setEndOriginId(end);
            vulnerabilityComputation.computeVulnerability(datastoreParams, null, 1, 1);
        } catch (IOException e) {
        }
    }
    
    private class VulnThread implements Runnable{

        private Long start;
        private Long end;
        
        public VulnThread(Long start, Long end){
            this.start = start;
            this.end = end;
        }
        
        @Override
        public void run() {
            computeVulnerability(start, end);
        }
        
    }
    
    @Test
    public void fullTest() throws Exception {
        
        String basePath = "C:\\Users\\geosolutions\\Documents\\destination\\targets_raster\\tiled\\";
        String imageName = "RP_COP-SUOLO_20130305.tif"; 
        String imgAbsolutePath = basePath + imageName;
        RenderedImage image = loadImage(true, new File(imgAbsolutePath));
        GeoTiffReader gtr = new GeoTiffReader(new File(imgAbsolutePath));
        
        String names[] = {"distance0","distance1"}; 
        Double distances[] = {8d,250d};
        Integer valuesA[] = {1,2,3,5,6};
        List<Integer> values = Arrays.asList(valuesA);
        DistancesPair dp = new DistancesPair(names, distances);
        
        SimpleFeatureType featureType = DataUtilities.createType("FLAG","id:Integer,name:String,*geometria:Geometry:32632");
        SimpleFeature feature = DataUtilities.createFeature(featureType, "1|test|MULTILINESTRING((433547.562 5050999,433541.9685 5050988.5,433528.9685 5050976.5,433520.75 5050968.5,433516.2185 5050959.5,433515.437 5050947,433524.4685 5050920.5,433528.6281 5050913.2663))" );
        
        Map<Double, Geometry> buffers = VulnerabilityUtils.computeBuffers(feature, dp);
        Geometry roiGeom = VulnerabilityUtils.toRasterSpace(buffers.get(250d), gtr);
        Double noData = VulnerabilityUtils.getNoDataValue(gtr);
        RenderedImage croppedImage = VulnerabilityUtils.cropImage(image, roiGeom);
        //List<Result> results = VulnerabilityUtils.sumCellsInsideBuffer(roiGeom, croppedImage, noData, 0, values);
        
        // save the files (with or without ROI) for a visual feedback
        RenderedImage[] imgArr = new RenderedImage[] { croppedImage };
        ROIGeometry[] rgeomArr = new ROIGeometry[] { new ROIGeometry(roiGeom) };
        RenderedOp ro = MosaicDescriptor.create(imgArr, MosaicDescriptor.MOSAIC_TYPE_OVERLAY, null,
                rgeomArr, null, new double[] { 0 }, null);
        File tmp = new File("C:\\Users\\geosolutions\\Documents\\destination\\targets_raster\\tiled\\test.png");
        //BufferedImage bi = ro.getAsBufferedImage();
        ImageIO.write(croppedImage, "png", tmp);
//        BufferedImage bi = ro.getAsBufferedImage();
//
//        File tmp2 = TestData.temp(this, "saved2.png");
//        ImageIO.write(bi, "png", tmp2);
        
    }
    
    public void testBuffer1() throws IOException {

        SimpleFeatureCollection features = createFeature();
        Double[] distances = new Double[] { 1.0 };
        MultipleBuffer buffers = new MultipleBuffer();
        String[] distanceNames = new String[] { "distance1", };
        SimpleFeatureCollection outputCollection = buffers.execute(features, null, null, distances,
                distanceNames);

        Geometry the_geom = null;

        SimpleFeatureIterator iter = outputCollection.features();
        while (iter.hasNext()) {
            SimpleFeature feature = iter.next();
            the_geom = (Geometry) feature.getDefaultGeometry();
            System.out.println(the_geom.getArea());
        }
        
        RenderedImage myData = createConstantImage();
        ROI roi = new ROIGeometry(the_geom);

        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", myData);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        // print results to console
        for (Result r : res.results()) {
            System.out.println(r);
        }
        
    }

    public void testBuffer2() throws IOException, ParseException, MismatchedDimensionException, TransformException {

        Geometry geom = createGeom();
        RenderedImage myData = loadImage(true, new File(imageURL));
        
        GeoTiffReader gtr = new GeoTiffReader(new File(imageURL));
        // get the world to grid matrix
        MathTransform g2w = gtr.getOriginalGridToWorld(PixelInCell.CELL_CORNER); // TODO Corner or Center?
        MathTransform w2g = g2w.inverse();
        Geometry targetGeom = JTS.transform(geom, w2g);
        
        Double[] distances = new Double[] { 200.0, 300.0, 400.0, 500.0 };
        MultipleBuffer buffers = new MultipleBuffer();
        String[] distanceNames = new String[] { "distance1", "distance2", "distance3", "distance4" };
        
        
        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName("featureType");
        tb.add("geometry", Geometry.class);
        tb.add("integer", Integer.class);
        SimpleFeatureBuilder b = new SimpleFeatureBuilder(tb.buildFeatureType());
        DefaultFeatureCollection features = new DefaultFeatureCollection(null, b.getFeatureType());
        b.add(targetGeom);
        b.add(0);
        features.add(b.buildFeature("piemontelinestring"));
        
        SimpleFeatureCollection outputCollection = buffers.execute(features, null, null, distances,
                distanceNames);

        Geometry the_geom = null;
        Geometry the_geom2 = null;
        Geometry the_geom3 = null;
        Geometry the_geom4 = null;

        SimpleFeatureIterator iter = outputCollection.features();
        while (iter.hasNext()) {

            SimpleFeature feature = iter.next();

            the_geom = (Geometry) feature.getDefaultGeometry();
            System.out.println(the_geom.getArea());

            // the_geom1 = (Geometry)feature.getAttribute("geometry1");
            // System.out.println(the_geom1.getArea());

            the_geom2 = (Geometry) feature.getAttribute("geometry2");
            System.out.println(the_geom2.getArea());

            the_geom3 = (Geometry) feature.getAttribute("geometry3");
            System.out.println(the_geom3.getArea());

            the_geom4 = (Geometry) feature.getAttribute("geometry4");
            System.out.println(the_geom4.getArea());

        }

        
        ROI roi = new ROIGeometry(the_geom);

        ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
        pb.setSource("dataImage", myData);
        // pb.setSource("zoneImage", myZones);
        pb.setParameter("roi", roi);

        Statistic[] stats = { Statistic.SUM, };

        pb.setParameter("stats", stats);
        RenderedOp op = JAI.create("ZonalStats", pb);

        ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);

        // print results to console
        for (Result r : res.results()) {
            System.out.println(r);
        }
    }

    private static SimpleFeatureCollection createFeature() {

        SimpleFeatureTypeBuilder tb = new SimpleFeatureTypeBuilder();
        tb.setName("featureType");
        tb.add("geometry", Geometry.class);
        tb.add("integer", Integer.class);

        GeometryFactory gf = new GeometryFactory();

        SimpleFeatureBuilder b = new SimpleFeatureBuilder(tb.buildFeatureType());
        DefaultFeatureCollection features = new DefaultFeatureCollection(null, b.getFeatureType());

        Coordinate array[] = new Coordinate[5];
        array[0] = new Coordinate(1, 1);
        array[1] = new Coordinate(1, 2);
        array[2] = new Coordinate(2, 2);
        array[3] = new Coordinate(2, 1);
        array[4] = new Coordinate(1, 1);
        LinearRing lr = gf.createLinearRing(array);
        Polygon p = gf.createPolygon(lr, null);
        b.add(p);
        features.add(b.buildFeature("1"));

        return features;
    }

    private static Geometry createGeom() throws ParseException {

        WKTReader wktReader = new WKTReader();
        Geometry sourceGeom = wktReader.read("LINESTRING(359136 5047674, 380407 5047590, 380995 5036492)");
        
        return sourceGeom;
    }

    /**
     * Loads a {@link RenderedImage} from the specified file with the specified mode.
     * 
     * @param mode, {@link ComputationMode} can be {@link ComputationMode#DEFERRED} or {@link ComputationMode#IMMEDIATE} as per the JAI meaning.
     * @param tiffFile the input {@link File} where to read from.
     * 
     * @return
     * @throws IOException in case the creation of the {@link ImageInputStream} or the Immediate read with Imageio fails.
     */
    private static RenderedImage loadImage(boolean deferred, File tiffFile) throws IOException {
        // checks
        if (!tiffFile.isFile() || !tiffFile.exists() || !tiffFile.canRead()) {
            throw new IllegalArgumentException("Unable to load image from file: "
                    + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                    + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
        }

        if (deferred) {
            final ImageInputStream inStream = ImageIO.createImageInputStream(tiffFile);
            if (inStream == null) {
                throw new IllegalArgumentException("Unable to create input stream from file: "
                        + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                        + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
            }
            return ImageReadDescriptor.create(inStream, Integer.valueOf(0), false, false, false,
                    null, null, null, null, null);
        } else {
            return ImageIO.read(tiffFile);

        }

    }

    private static PlanarImage createConstantImage() {

        RenderingHints hints = null;

        ParameterBlockJAI pb = new ParameterBlockJAI("constant");
        pb.setParameter("width", 128f);
        pb.setParameter("height", 128f);
        pb.setParameter("bandValues", new Double[] { 1.0 });

        return JAI.create("constant", pb, hints).getRendering();
    }

}
