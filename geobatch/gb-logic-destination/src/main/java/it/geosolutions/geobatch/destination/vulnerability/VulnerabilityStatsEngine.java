/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;

import java.awt.image.RenderedImage;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.geotools.jdbc.JDBCDataStore;
import org.jaitools.media.jai.zonalstats.Result;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.referencing.operation.MathTransform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vividsolutions.jts.geom.Geometry;

/**
 * @author DamianoG
 * 
 */
public class VulnerabilityStatsEngine {

    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityStatsEngine.class);

    private Properties targetURIs;

    private List<Double> distances;

    private Map<String, TargetInfo> targetInfo;

    // static{
    // try {
    // propertiesLoader = new TargetPropertiesLoader();
    // targetURIs = propertiesLoader.getTargetURIs();
    // targetReaders = VulnerabilityUtils.loadGTIFFReaders(targetURIs);
    // targetRasters = VulnerabilityUtils.loadImages(targetURIs);
    // } catch (IOException e) {
    // LOGGER.error(e.getMessage(), e);
    // }
    // }

    public VulnerabilityStatsEngine(TargetPropertiesLoader propertiesLoader,
            JDBCDataStore dataStore, String typeName, int pixelArea) throws IOException {
        final List<Double> allDistances = TargetPropertiesLoader.loadDistances(dataStore, typeName);
        targetURIs = propertiesLoader.getTargetURIs();
        targetInfo = VulnerabilityUtils.loadTargets(targetURIs, pixelArea);

        Properties targetMapping = propertiesLoader.getTargetMapping();
        // Map<Integer, String> valuesZone = propertiesLoader.getTargetValuesZone();
        // ResultStatsMap statsMap = new ResultStatsMap(targetMapping, valuesZone);
        Properties zoneValues = propertiesLoader.getTargetZoneValues();
        logVulnerabilityConfiguration(allDistances, targetMapping, zoneValues);
        distances = refineDistances(allDistances, pixelArea);
    }

    public List<Double> getDistances() {
        return distances;
    }

    /**
     * Scan all targets looking for actual distances which are globally needed
     * 
     * @param targetRasters
     * @param allDistances
     * @return
     */
    public List<Double> refineDistances(final List<Double> allDistances, int pixelArea) {
        Iterator<String> rasterIter = targetInfo.keySet().iterator();
        Set<Double> foundDistances = new HashSet<Double>();
        List<Double> refinedDistances = new ArrayList<Double>();

        // Load all distances used by all targets
        while (rasterIter.hasNext()) {

            final String targetID = (String) rasterIter.next();
            TargetManager targetManager = targetInfo.get(targetID).getManager();
            
            // Load the target manager, init its status and check if the actual distance is a valid distance for it
            List<Double> targetDistances = targetManager.getDistances();
            for (Double d : targetDistances) {
                foundDistances.add(d);
            }
        }
        // Refine the all distances list by not including distances which aren't needed
        // by at least one target
        for (Double mainDistance : allDistances) {
            if (foundDistances.contains(mainDistance)) {
                refinedDistances.add(mainDistance);
            }
        }
        return refinedDistances;
    }

    public MultipleBufferMap computeBuffersOnArcs(List<SimpleFeature> inputFeatures,
            List<Double> allDistances) {
        MultipleBufferMap mbm = new MultipleBufferMap();
        for (SimpleFeature feat : inputFeatures) {
            DistancesPair allDistancesForComputation = TargetPropertiesLoader
                    .createPairDistance(allDistances);
            Map<Double, Geometry> buffersMap = VulnerabilityUtils.computeBuffers(feat,
                    allDistancesForComputation);
            mbm.addMap(buffersMap);
        }
        return mbm;
    }

    /**
     * Retrieve the buffer of the arc in the raster space and crop the raster of the target in the raster of the buffer BBOX to run the stats on a
     * smaller raster
     * 
     * @param targetID
     * @param buffers
     * @return
     * @throws Exception
     */
    public RenderedImage cropImage(String targetID, Geometry roiGeom) throws Exception {
        RenderedImage image = targetInfo.get(targetID).getRaster();
        RenderedImage croppedImage = VulnerabilityUtils.cropImage(image, roiGeom);
        return croppedImage;
    }

    /**
     * Retrieve the raster space version of the specified cropArea geometry
     * 
     * @param targetID
     * @param buffers
     * @return
     * @throws Exception
     */
    public Geometry getRasterGeometry(String targetID, Geometry cropArea) throws Exception {
        MathTransform w2g = targetInfo.get(targetID).getWorld2Grid();
        Geometry roiGeom = VulnerabilityUtils.toRasterSpace(cropArea, w2g);
        return roiGeom;
    }

    /**
     * Retrieve the NoData value for the raster related to a target
     * 
     * @param targetID
     * @return
     */
    public Double getNoData(String targetID) {
        return targetInfo.get(targetID).getNodata();
    }

    public Map<String, TargetInfo> getTargetInfo() {
        return targetInfo;
    }

    /**
     * Check if a previous crop operation was succesful on all rasters
     * 
     * @param croppedImages
     * @return
     */
    public boolean validateCroppedImages(List<RenderedImage> croppedImages) {
        for (RenderedImage croppedImage : croppedImages) {
            if (croppedImage == null) {
                return false;
            }
        }
        return true;
    }

    /**
     * 
     * Compute the stats and create the statsMap
     * 
     * @param roiGeom
     * @param image
     * @param noData
     * @param resMap
     * @param forceToZero
     * @param targetManager
     * @param valuesToCount
     * @throws Exception
     */
    public void computeStats(List<Geometry> roiGeom, RenderedImage croppedImage,
            ResultStatsMap resMap, boolean forceToZero, TargetInfo targetInfo)
            throws Exception {
        final Double noData = targetInfo.getNodata();
        final MathTransform w2g = targetInfo.getWorld2Grid();
        final TargetManager targetManager = targetInfo.getManager();
        for (Geometry roi : roiGeom) {
            Geometry rasterRoi = VulnerabilityUtils.toRasterSpace(roi, w2g);
            List<Result> results = VulnerabilityUtils.sumCellsInsideBuffer(rasterRoi, croppedImage,
                    noData, 0, targetManager.getPixelValues());
            ResultStatsMap otherMap = resMap.clone();
            targetManager.handleResults(results, otherMap, forceToZero);
            resMap.sum(otherMap);
        }
    }
    
    /**
     * 
     * Compute the stats and create the statsMap
     * 
     * @param roiGeom
     * @param image
     * @param noData
     * @param resMap
     * @param forceToZero
     * @param targetManager
     * @param valuesToCount
     * @throws Exception
     */
    public void computeStats(Geometry rasterRoi, RenderedImage croppedImage, ResultStatsMap resMap,
            boolean forceToZero, TargetInfo targetInfo) throws Exception {
        final Double noData = targetInfo.getNodata();
        final TargetManager targetManager = targetInfo.getManager();

        List<Result> results = VulnerabilityUtils.sumCellsInsideBuffer(rasterRoi, croppedImage,
                noData, 0, targetManager.getPixelValues());
        ResultStatsMap otherMap = resMap.clone();
        targetManager.handleResults(results, otherMap, forceToZero);
        resMap.sum(otherMap);

    }

    /**
     * This method logs the main information before the vulnerability process start
     * 
     * Issue: logs all distance stored not those specifyed in the properties file
     * 
     * @param targetRasters
     * @param allDistances
     * @param targetMapping
     * @param zoneValues
     */
    private void logVulnerabilityConfiguration(List<Double> allDistances, Properties targetMapping,
            Properties zoneValues) {
        Iterator rasterIter = targetInfo.keySet().iterator();
        StringBuilder sb = new StringBuilder();
        sb.append("rasterLoaded:[ ");
        while (rasterIter.hasNext()) {
            sb.append((String) rasterIter.next()).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());

        sb = new StringBuilder();
        sb.append("distanceLoaded:[ ");
        for (Double el : allDistances) {
            sb.append(el).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());

        sb = new StringBuilder();
        sb.append("tableVulnerabilityMapping:[ ");
        Iterator targetMappingIter = targetMapping.keySet().iterator();
        while (targetMappingIter.hasNext()) {
            String key = (String) targetMappingIter.next();
            sb.append(key).append("-").append(targetMapping.getProperty(key)).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());

        sb = new StringBuilder();
        sb.append("zoneValuesCopSuolo:[ ");
        Iterator zoneValuesIter = zoneValues.keySet().iterator();
        while (zoneValuesIter.hasNext()) {
            String key = (String) zoneValuesIter.next();
            sb.append(key).append("-").append(zoneValues.getProperty(key)).append(", ");
        }
        sb.append("]");
        LOGGER.info(sb.toString());
    }
}
